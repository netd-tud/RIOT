/*
 * Copyright (C) 2024 TU Dresden
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @ingroup     sys_psa_crypto
 * @defgroup    sys_psa_crypto_hkdf PSA KDF
 * @{
 *
 * @file        psa_hmac.h
 * @brief       Function declarations for PSA Crypto HKDF implementation.
 *
 * @author      Daria Zatokovenko <daria.zatokovenko@mailbox.tu-dresden.de>
 *
 * @}
 */

#ifndef PSA_HKDF_H
#define PSA_HKDF_H

#ifdef __cplusplus
extern "C" {
#endif

#include "kernel_defines.h"

#include <psa/crypto.h>
#include "psa/crypto_contexts.h"

#include <psa/crypto_types.h>
#include <psa/crypto_struct.h>

#include <stdbool.h>


/**
 * @brief   Structure containing the HKDF key derivation context.
 */
typedef struct {
    const uint8_t *salt;        /**< Salt value for the HKDF operation. */
    size_t salt_length;         /**< Length of the salt value. */
    const uint8_t *ikm;         /**< Input keying material for the HKDF operation. */
    size_t ikm_length;          /**< Length of the input keying material. */
    const uint8_t *info;        /**< Non-secret value that is used in the expansion phase. */
    size_t info_length;         /**< Length of the info. */
    uint8_t *prk;               /**< Buffer to hold the pseudorandom key (PRK). */
    size_t prk_length;          /**< Length of the pseudorandom key. */
    psa_algorithm_t hash_alg;   /**< Hash algorithm used in the HKDF operation. */
    size_t hash_length;         /**< Length of the hash. */
} psa_hkdf_key_derivation_ctx_t;

/**
 * @brief   Low level function to initialize the key derivation operation
 *          See @ref psa_key_derivation_setup()
 *
 * @param operation
 * @param alg
 * @return psa_status_t
 */
psa_status_t psa_hkdf_key_derivation_setup(psa_key_derivation_operation_t *operation,
                                           psa_algorithm_t alg);

/**
 * @brief   Low level function to pass direct input to the key derivation operation
 *          See @ref psa_key_derivation_input_bytes()
 * 
 * @param operation
 * @param step
 * @param data
 * @param data_length
 * @param alg
 * @return psa_status_t
 */
psa_status_t psa_hkdf_input_bytes(psa_key_derivation_operation_t *operation,
                                  psa_key_derivation_step_t step,
                                  const uint8_t *data,
                                  size_t data_length,
                                  psa_algorithm_t alg);

/**
 * @brief   Low level function to pass secret material for the key derivation operation
 *          See @ref psa_key_derivation_input_key()
 *
 * @param operation
 * @param step
 * @param key_type
 * @param data
 * @param data_length
 * @param alg
 * @return psa_status_t
 */
psa_status_t psa_hkdf_input_key(psa_key_derivation_operation_t *operation,
                                psa_key_derivation_step_t step,
                                psa_key_type_t key_type,
                                const uint8_t *data,
                                size_t data_length,
                                psa_algorithm_t alg);

/**
 * @brief   Low level function to read data from a key derivation operation
 *          See @ref psa_key_derivation_output_bytes()
 *
 *
 * @param operation
 * @param output
 * @param output_length
 * @param alg
 * @return psa_status_t
 */
psa_status_t psa_hkdf_output_bytes(psa_key_derivation_operation_t *operation,
                                   uint8_t *output,
                                   size_t output_length,
                                   psa_algorithm_t alg);

/**
 * @brief   Low level function to output the derived key
 *          See @ref psa_key_derivation_output_key()
 *
 * @param operation
 * @param key_buffer
 * @param key_buffer_size
 * @return psa_status_t
 */
psa_status_t psa_hkdf_output_key(psa_key_derivation_operation_t *operation,
                                 uint8_t *key_buffer,
                                 size_t *key_buffer_size);

/**
 * @brief   Low level function to generate the derived key
 *          The derived key is generated by calling the HKDF expand function
 *          to derive the key from the PRK.
 *          The derived key is stored in the key buffer.
 *
 * @param operation
 * @param key_buffer
 * @param key_buffer_size
 * @return psa_status_t
 */
psa_status_t psa_generate_derived_key(
    psa_key_derivation_operation_t *operation,
    uint8_t *key_buffer,
    size_t key_buffer_size);

/**
 * @brief   Low level function to compute the extract step of HKDF.
 *          The HKDF extract step is used to extract a pseudorandom key from the input keying material (IKM).
 *          The output of the extract step is a pseudorandom key of the desired length.
 *          The output is generated by calculating the HMAC of the IKM and the salt.
 *          The output is the pseudorandom key (PRK) and is used as the key for the expand step.
 *
 * @param operation
 * @param ikm
 * @param ikm_length
 * @param salt
 * @param salt_length
 * @return psa_status_t
 */
psa_status_t hkdf_extract(psa_key_derivation_operation_t *operation,
                          const uint8_t *ikm, size_t ikm_length,
                          const uint8_t *salt, size_t salt_length);

/**
 * @brief   Low level function to compute the expand step of HKDF.
 *          The HKDF expand step is used to derive multiple keys from the PRK.
 *          The output of the expand step is a pseudorandom key of the desired length.
 *          The counter is a single byte that is incremented for each iteration.
 *          The output is generated by concatenating multiple HMACs of the PRK with the info and a counter.
 *          The output is truncated to the desired length.
 *
 * @param operation
 * @param output
 * @param output_length
 * @return psa_status_t
 */
psa_status_t hkdf_expand(psa_key_derivation_operation_t *operation,
                         uint8_t *output, size_t output_length);

/**
 * @brief   Function to check if the step is valid for the current state of the operation.
 *
 * @param state
 * @param step
 * @return bool
 */
bool is_valid_step_for_current_state(operation_state_t state,
                                     psa_key_derivation_step_t step);

#ifdef __cplusplus
}
#endif

#endif /* PSA_KDF_H */
/**@}*/
